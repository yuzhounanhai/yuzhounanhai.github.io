<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>实现符合Promise A+规范的promise | 南海の笔记</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="promise的简单使用promise是异步的解决方案之一，可以通过实例化 Promise 类，并传入一个 executor 来进行使用。executor 是一个函数，该函数的两个参数分别是 resolve 和 reject 。它们是两个由 JavaScript 引擎提供的函数。分别用以成功回调以及错误回调。 1234567const p = new Promise(function(resolv">
<meta name="keywords" content="原理,JS">
<meta property="og:type" content="article">
<meta property="og:title" content="实现符合Promise A+规范的promise">
<meta property="og:url" content="https://yuzhounanhai.github.io/2019/09/29/实现符合promisea+规范/index.html">
<meta property="og:site_name" content="南海の笔记">
<meta property="og:description" content="promise的简单使用promise是异步的解决方案之一，可以通过实例化 Promise 类，并传入一个 executor 来进行使用。executor 是一个函数，该函数的两个参数分别是 resolve 和 reject 。它们是两个由 JavaScript 引擎提供的函数。分别用以成功回调以及错误回调。 1234567const p = new Promise(function(resolv">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-09-03T02:26:31.355Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="实现符合Promise A+规范的promise">
<meta name="twitter:description" content="promise的简单使用promise是异步的解决方案之一，可以通过实例化 Promise 类，并传入一个 executor 来进行使用。executor 是一个函数，该函数的两个参数分别是 resolve 和 reject 。它们是两个由 JavaScript 引擎提供的函数。分别用以成功回调以及错误回调。 1234567const p = new Promise(function(resolv">
  
    <link rel="alternate" href="/atom.xml" title="南海の笔记" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">南海の笔记</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">在海的南边，有一片宇宙！宇宙无垠，而探索无尽，是该同懒癌佛系奋斗！</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://yuzhounanhai.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-实现符合promisea+规范" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/09/29/实现符合promisea+规范/" class="article-date">
  <time datetime="2019-09-29T07:59:45.737Z" itemprop="datePublished">2019-09-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/前端/">前端</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      实现符合Promise A+规范的promise
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        
          <h2 id="promise的简单使用"><a href="#promise的简单使用" class="headerlink" title="promise的简单使用"></a>promise的简单使用</h2><p>promise是异步的解决方案之一，可以通过实例化 Promise 类，并传入一个 executor 来进行使用。<br>executor 是一个函数，该函数的两个参数分别是 resolve 和 reject 。它们是两个由 JavaScript 引擎提供的函数。分别用以成功回调以及错误回调。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="comment">/*异步操作成功*/</span>) &#123;</span><br><span class="line">        resolve(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<p>Promise 实例生成以后，可以用 then 方法分别指定 resolved 状态和 rejected 状态的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// success</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// error</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h4><p>根据上述使用简单实现 promise：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="keyword">this</span>;    <span class="comment">// 缓存当前promise实例</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        executor();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码将作为基本内容，将会结合后面的 promise A+ 规范进行改造。</p>
<h2 id="Promise-A-规范"><a href="#Promise-A-规范" class="headerlink" title="Promise A+ 规范"></a>Promise A+ 规范</h2><blockquote>
<p><a href="https://promisesaplus.com/" target="_blank" rel="noopener">promise A+ 规范英文版</a></p>
</blockquote>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h4 id="promise的状态"><a href="#promise的状态" class="headerlink" title="promise的状态"></a>promise的状态</h4><blockquote>
<p>2.1: A promise must be in one of three states: pending, fulfilled, or rejected.<br>  2.1.1.1: When pending, a promise: may transition to either the fulfilled or rejected state.<br>  2.1.2.1: When fulfilled, a promise: must not transition to any other state.<br>  2.1.3.1: When rejected, a promise: must not transition to any other state.</p>
</blockquote>
<p>Promise只有三种状态，promise 的状态值必须是这三种值之一，且 pending 可变为其他状态，fulfilled、rejected 不可变。<br>pending为初始态。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'pending'</span>;      <span class="comment">// add</span></span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">'fulfilled'</span>;  <span class="comment">// add</span></span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'rejected'</span>;    <span class="comment">// add</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">    self.status = PENDING;      <span class="comment">// add</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        executor();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>2.1.2.2: When fulfilled, a promise: must have a value, which must not change.<br>2.1.3.2: When rejected, a promise: must have a reason, which must not change.</p>
</blockquote>
<p>调用 resolve 的时候，promise 将会变为 fulfilled 状态，并且变为该状态需要有一个value，也就意味着 resolve 方法将接收一个 value。<br>调用 reject 的时候，promise 将会变为 rejected 状态，并且变为该状态需要有一个 reason，也就意味着 reject 方法将接收一个 reason。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// other code...</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (self.status === PENDING) &#123;</span><br><span class="line">            self.status = FULFILLED;</span><br><span class="line">            self.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (self.status === PENDING) &#123;</span><br><span class="line">            self.status = REJECTED;</span><br><span class="line">            self.reason = reason;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// other code...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="then-method"><a href="#then-method" class="headerlink" title="then method"></a>then method</h4><blockquote>
<p>2.2: A promise must provide a then method to access its current or eventual value or reason.<br>A promise’s then method accepts two arguments:<br>promise.then(onFulfilled, onRejected)<br>2.2.1: Both onFulfilled and onRejected are optional arguments:<br>  2.2.1.1: If onFulfilled is not a function, it must be ignored.<br>  2.2.1.2: If onRejected is not a function, it must be ignored.</p>
</blockquote>
<p>then方法接收两个函数参数：<code>onFulfilled</code>, <code>onRejected</code>，这两个参数如果不是函数，需要被忽略(并做出兼容方法)，因此在then方法中需要判断这两个参数的类型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">    onFulfilled = </span><br><span class="line">        <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span></span><br><span class="line">            ? onFulfilled </span><br><span class="line">            : <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line">    onRejected = </span><br><span class="line">        <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> </span><br><span class="line">            ? onRejected </span><br><span class="line">            : <span class="function"><span class="params">reason</span> =&gt;</span> &#123; <span class="keyword">throw</span> reason; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="根据promise的状态分情况执行"><a href="#根据promise的状态分情况执行" class="headerlink" title="根据promise的状态分情况执行"></a>根据promise的状态分情况执行</h6><blockquote>
<p>2.2.2: If onFulfilled is a function:<br>  2.2.2.1: it must be called after promise is fulfilled, with promise’s value as its first argument.<br>  2.2.2.2: it must not be called before promise is fulfilled.<br>  2.2.2.3: it must not be called more than once.</p>
<p>2.2.3: If onRejected is a function,<br>  2.2.3.1: it must be called after promise is rejected, with promise’s reason as its first argument.<br>  2.2.3.2: it must not be called before promise is rejected.<br>  2.2.3.3: it must not be called more than once.</p>
</blockquote>
<ul>
<li>如果是fulfilled: 执行onFulfilled()</li>
<li>如果是rejected: 执行onRejected()</li>
<li>如果是pending：promise中有异步请求，需要将<code>onFulfilled</code>和<code>onRejected</code>封装为回调，并使promise在状态改变时执行相关回调。</li>
</ul>
<p>因此需要改造代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'pending'</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">'fulfilled'</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'rejected'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="keyword">this</span>;    <span class="comment">// 缓存当前promise实例</span></span><br><span class="line">    self.status = PENDING;</span><br><span class="line">    <span class="comment">// 定义存放成功回调的数组</span></span><br><span class="line">    self.onResolvedCallbacks = [];  <span class="comment">// add</span></span><br><span class="line">    <span class="comment">// 定义存放失败回调的数组</span></span><br><span class="line">    self.onRejectedCallbacks = [];  <span class="comment">// add</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (self.status === PENDING) &#123;</span><br><span class="line">            self.status = FULFILLED;</span><br><span class="line">            self.value = value;</span><br><span class="line">            self.onResolvedCallbacks.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb(self.value)); <span class="comment">// add</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (self.status === PENDING) &#123;</span><br><span class="line">            self.status = REJECTED;</span><br><span class="line">            self.reason = reason;</span><br><span class="line">            self.onRejectedCallbacks.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb(self.reason)); <span class="comment">// add</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        executor();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line">    onFulfilled = </span><br><span class="line">        <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span></span><br><span class="line">            ? onFulfilled </span><br><span class="line">            : <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line">    onRejected = </span><br><span class="line">        <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> </span><br><span class="line">            ? onRejected </span><br><span class="line">            : <span class="function"><span class="params">reason</span> =&gt;</span> &#123; <span class="keyword">throw</span> reason; &#125;;</span><br><span class="line">    <span class="comment">// add</span></span><br><span class="line">    <span class="keyword">if</span> (self.status === PENDING) &#123;</span><br><span class="line">        self.onResolvedCallbacks.push(onFulfilled);</span><br><span class="line">        self.onRejectedCallbacks.push(onRejected);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (self.status === FULFILLED) &#123;</span><br><span class="line">        onFulfilled(self.value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (self.status === REJECTED) &#123;</span><br><span class="line">        onRejected(self.reason);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>2.2.7: then must return a promise.<br>promise2 = promise1.then(onFulfilled, onRejected);<br>  2.2.7.1: If either onFulfilled or onRejected returns a value x, run the Promise Resolution Procedure [[Resolve]](promise2, x).</p>
</blockquote>
<p>then方法需要返回一个promise2，如果 onFulfilled 和 onRejected 返回一个值x，需要进行promise的解析。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">let</span> promise2;</span><br><span class="line">    <span class="keyword">if</span> (self.status === PENDING) &#123;</span><br><span class="line">        <span class="keyword">return</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">            self.onResolvedCallbacks.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">let</span> x = onFulfilled(self.value);</span><br><span class="line">                resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">            &#125;);</span><br><span class="line">            self.onRejectedCallbacks.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">let</span> x = onRejected(self.reason);</span><br><span class="line">                resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (self.status === FULFILLED) &#123;</span><br><span class="line">        <span class="keyword">return</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> x = onFulfilled(self.value);</span><br><span class="line">            resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (self.status === REJECTED) &#123;</span><br><span class="line">        <span class="keyword">return</span>  promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> x = onRejected(self.reason);</span><br><span class="line">            resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>  2.2.7.2: If either onFulfilled or onRejected throws an exception e, promise2 must be rejected with e as the reason.<br>  2.2.7.3: If onFulfilled is not a function and promise1 is fulfilled, promise2 must be fulfilled with the same value as promise1.<br>  2.2.7.4: If onRejected is not a function and promise1 is rejected, promise2 must be rejected with the same reason as promise1.</p>
</blockquote>
<p>在执行 onFulfilled 或者 onRejected 时遇到了抛出的异常，promise2需要 reject 这个异常。也就是说我们需要在执行时做try-catch，下面展示部分代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (self.status === FULFILLED) &#123;</span><br><span class="line">    <span class="keyword">return</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = onFulfilled(self.value);</span><br><span class="line">            resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">            reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.2.7.3 与 2.2.7.4 的处理其实就是上文中 onFulfilled 与 onRejected 类型判断的兼容方案：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">onFulfilled = </span><br><span class="line">    <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span></span><br><span class="line">        ? onFulfilled </span><br><span class="line">        : <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line"><span class="comment">// 抛出错误就会走到catch分支</span></span><br><span class="line">onRejected = </span><br><span class="line">    <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> </span><br><span class="line">        ? onRejected </span><br><span class="line">        : <span class="function"><span class="params">reason</span> =&gt;</span> &#123; <span class="keyword">throw</span> reason; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="resolvePromise"><a href="#resolvePromise" class="headerlink" title="resolvePromise"></a>resolvePromise</h4><blockquote>
<p>2.3.1: If promise and x refer to the same object, reject promise with a TypeError as the reason.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (promise2 === x) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'循环引用'</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>2.3.2: If x is a promise, adopt its state:<br>  2.3.2.1: If x is pending, promise must remain pending until x is fulfilled or rejected.<br>  2.3.2.2: If/when x is fulfilled, fulfill promise with the same value.<br>  2.3.2.3: If/when x is rejected, reject promise with the same reason.</p>
</blockquote>
<p>如果x是一个promise，必须等待promise进入最终的状态后，并返回最终状态的值，按照这一说法我们可以得出以下代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (promise2 === x) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'循环引用'</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// add</span></span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x.status === PENDING) &#123;</span><br><span class="line">            x.then(<span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// y也可能是一个promise</span></span><br><span class="line">                resolvePromise(promise2, y, resolve, reject);</span><br><span class="line">            &#125;, reject);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            x.then(resolve, reject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这部分代码不是必要的，我们完全可以将promise的执行交由resolve函数：如果value（即x）是promise，会层层执行，并执行对应的resolve和reject</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// add</span></span><br><span class="line">        <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> value.then(resolve, reject);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (self.status === PENDING) &#123;</span><br><span class="line">            self.status = FULFILLED;</span><br><span class="line">            self.value = value;</span><br><span class="line">            self.onResolvedCallbacks.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb(self.value)); <span class="comment">// add</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>2.3.3: Otherwise, if x is an object or function,<br>  2.3.3.1: Let then be x.then.<br>  2.3.3.2: If retrieving the property x.then results in a thrown exception e, reject promise with e as the reason.<br>  2.3.3.3: If then is a function, call it with x as this, first argument resolvePromise, and second argument rejectPromise, where:<br>      2.3.3.3.1: If/when resolvePromise is called with a value y, run [[Resolve]](promise, y).<br>      2.3.3.3.2: If/when rejectPromise is called with a reason r, reject promise with r.<br>      2.3.3.3.3: If both resolvePromise and rejectPromise are called, or multiple calls to the same argument are made, the first call takes precedence, and any further calls are ignored.<br>      2.3.3.3.4: If calling then throws an exception e,<br>          2.3.3.3.4.1: If resolvePromise or rejectPromise have been called, ignore it.<br>          2.3.3.3.4.2: Otherwise, reject promise with e as the reason.<br>  2.3.4: If then is not a function, fulfill promise with x.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 避免多次调用</span></span><br><span class="line">    <span class="keyword">let</span> isCalled = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (promise2 === x) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'循环引用'</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">'function'</span> &amp;&amp; (x &amp;&amp; <span class="keyword">typeof</span> x === <span class="string">'object'</span>)) &#123;</span><br><span class="line">        <span class="comment">// 避免 typeof null 是 'object' 的问题</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> then = x.then;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123;</span><br><span class="line">                then.call(x, <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (isCalled) <span class="keyword">return</span>;</span><br><span class="line">                    isCalled = <span class="literal">true</span>;</span><br><span class="line">                    resolvePromise(promise2, y, resolve, reject);</span><br><span class="line">                &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">r</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (isCalled) <span class="keyword">return</span>;</span><br><span class="line">                    isCalled = <span class="literal">true</span>;</span><br><span class="line">                    reject(r);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 说明是一个普通对象/函数</span></span><br><span class="line">                resolve(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isCalled) <span class="keyword">return</span>;</span><br><span class="line">            isCalled = <span class="literal">true</span>;</span><br><span class="line">            reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>2.2.4: onFulfilled or onRejected must not be called until the execution context stack contains only platform code. [3.1].<br>注释3.1: Here “platform code” means engine, environment, and promise implementation code. In practice, this requirement ensures that onFulfilled and onRejected execute asynchronously, after the event loop turn in which then is called, and with a fresh stack. This can be implemented with either a “macro-task” mechanism such as setTimeout or setImmediate, or with a “micro-task” mechanism such as MutationObserver or process.nextTick. Since the promise implementation is considered platform code, it may itself contain a task-scheduling queue or “trampoline” in which the handlers are called.</p>
</blockquote>
<p>这里的意思是说 onFulfilled 和 onRejected 需要异步执行, 且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (self.status === PENDING) &#123;</span><br><span class="line">        <span class="keyword">return</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">            self.onResolvedCallbacks.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// add</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> x = onFulfilled(self.value);</span><br><span class="line">                        resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">                        reject(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">            self.onRejectedCallbacks.push(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// add</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">let</span> x = onRejected(self.reason);</span><br><span class="line">                        resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">                        reject(e);</span><br><span class="line">                    &#125; </span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (self.status === FULFILLED) &#123;</span><br><span class="line">        <span class="keyword">return</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// add</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> x = onFulfilled(self.value);</span><br><span class="line">                    resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">                    reject(e);</span><br><span class="line">                &#125;     </span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (self.status === REJECTED) &#123;</span><br><span class="line">        <span class="keyword">return</span>  promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// add</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">let</span> x = onRejected(self.reason);</span><br><span class="line">                    resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">                &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">                    reject(e);</span><br><span class="line">                &#125;     </span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试promise-A-规范"><a href="#测试promise-A-规范" class="headerlink" title="测试promise A+规范"></a>测试promise A+规范</h3><ol>
<li>npm全局安装<code>promises-aplus-tests</code>库</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g promises-aplus-tests</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在自己实现promise的js文件中暴露promise模块</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果你自己实现的promise叫MyPromise </span></span><br><span class="line"><span class="comment">// 则对应的代码就是</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MyPromise.defer = MyPromise.deferred = function() &#123;</span></span><br><span class="line"><span class="comment"> *  let dfd = &#123;&#125;;</span></span><br><span class="line"><span class="comment"> *  dfd.promise = new MyPromise((resolve, reject) =&gt; &#123;</span></span><br><span class="line"><span class="comment"> *    dfd.resolve = resolve;</span></span><br><span class="line"><span class="comment"> *    dfd.reject = reject;</span></span><br><span class="line"><span class="comment"> *  &#125;);</span></span><br><span class="line"><span class="comment"> *  return dfd;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * module.exports = MyPromise;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">Promise</span>.defer = <span class="built_in">Promise</span>.deferred = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> dfd = &#123;&#125;;</span><br><span class="line">  dfd.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    dfd.resolve = resolve;</span><br><span class="line">    dfd.reject = reject;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> dfd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="built_in">Promise</span>;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>命令行在当前文件目录下键入测试命令</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promises-aplus-tests 文件名.js</span><br></pre></td></tr></table></figure>

<h5 id="通过创建package-json局部安装测试库"><a href="#通过创建package-json局部安装测试库" class="headerlink" title="通过创建package.json局部安装测试库"></a>通过创建package.json局部安装测试库</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;devDependencies&quot;: &#123;</span><br><span class="line">        &quot;promises-aplus-tests&quot;: &quot;*&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;scripts&quot;: &#123;</span><br><span class="line">        &quot;test&quot;: &quot;promises-aplus-tests 文件名.js&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建完成后，按照熟悉的前端跑项目流程即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i</span><br><span class="line">npm run test</span><br></pre></td></tr></table></figure>

<h2 id="完整代码（新版）"><a href="#完整代码（新版）" class="headerlink" title="完整代码（新版）"></a>完整代码（新版）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> STATUS = &#123;</span><br><span class="line">  pending: <span class="string">'pending'</span>,</span><br><span class="line">  fulfilled: <span class="string">'fulfilled'</span>,</span><br><span class="line">  rejected: <span class="string">'rejected'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(excutor) &#123;</span><br><span class="line">    <span class="keyword">this</span>.status = STATUS.pending;</span><br><span class="line">    <span class="keyword">this</span>.onFinishCb = [];</span><br><span class="line">    <span class="keyword">const</span> resolve = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value.then(resolve, reject);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// When pending, a promise may transition to either the fulfilled or rejected state.</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === STATUS.pending) &#123;</span><br><span class="line">        <span class="keyword">this</span>.status = STATUS.fulfilled;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="comment">// f/when promise is fulfilled, all respective onFulfilled callbacks must execute in the order of their originating calls to then</span></span><br><span class="line">        <span class="keyword">this</span>.onFinishCb.forEach(<span class="function"><span class="params">cbObj</span> =&gt;</span> cbObj.onFullfilled(<span class="keyword">this</span>.value));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> reject = <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// When pending, a promise may transition to either the fulfilled or rejected state.</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === STATUS.pending) &#123;</span><br><span class="line">        <span class="keyword">this</span>.status = STATUS.rejected;</span><br><span class="line">        <span class="keyword">this</span>.reason = reason;</span><br><span class="line">        <span class="comment">// If/when promise is rejected, all respective onRejected callbacks must execute in the order of their originating calls to then</span></span><br><span class="line">        <span class="keyword">this</span>.onFinishCb.forEach(<span class="function"><span class="params">cbObj</span> =&gt;</span> cbObj.onRejected(<span class="keyword">this</span>.reason));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      excutor(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> isCalled = <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// If promise and x refer to the same object, reject promise with a TypeError as the reason.</span></span><br><span class="line">  <span class="keyword">if</span> (promise2 === x) &#123;</span><br><span class="line">    <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'循环引用'</span>));</span><br><span class="line">    <span class="comment">// If x is a promise, adopt its state 走else分支 交给resolve函数处理</span></span><br><span class="line">    <span class="comment">// Otherwise, if x is an object or function</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x === <span class="string">'function'</span> || (x &amp;&amp; <span class="keyword">typeof</span> x === <span class="string">'object'</span>)) &#123;</span><br><span class="line">    <span class="comment">// If retrieving the property x.then results in a thrown exception e, reject promise with e as the reason.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Let then be x.then</span></span><br><span class="line">      <span class="keyword">let</span> then = x.then;</span><br><span class="line">      <span class="comment">// If then is a function, call it with x as this, first argument resolvePromise, and second argument rejectPromise</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123;</span><br><span class="line">        <span class="comment">// If/when resolvePromise is called with a value y, run [[Resolve]](promise, y).</span></span><br><span class="line">        <span class="keyword">const</span> resolvePromiseFn = <span class="function"><span class="keyword">function</span> (<span class="params">y</span>) </span>&#123;</span><br><span class="line">          <span class="comment">// If both resolvePromise and rejectPromise are called,</span></span><br><span class="line">          <span class="comment">// or multiple calls to the same argument are made,</span></span><br><span class="line">          <span class="comment">// the first call takes precedence,</span></span><br><span class="line">          <span class="comment">// and any further calls are ignored.</span></span><br><span class="line">          <span class="keyword">if</span> (isCalled) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          isCalled = <span class="literal">true</span>;</span><br><span class="line">          resolvePromise(promise2, y, resolve, reject);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// If/when rejectPromise is called with a reason r, reject promise with r.</span></span><br><span class="line">        <span class="keyword">const</span> rejectPromiseFn = <span class="function"><span class="keyword">function</span> (<span class="params">r</span>) </span>&#123;</span><br><span class="line">          <span class="comment">// If both resolvePromise and rejectPromise are called,</span></span><br><span class="line">          <span class="comment">// or multiple calls to the same argument are made,</span></span><br><span class="line">          <span class="comment">// the first call takes precedence,</span></span><br><span class="line">          <span class="comment">// and any further calls are ignored.</span></span><br><span class="line">          <span class="keyword">if</span> (isCalled) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          isCalled = <span class="literal">true</span>;</span><br><span class="line">          reject(r);</span><br><span class="line">        &#125;;</span><br><span class="line">        then.call(x, resolvePromiseFn, rejectPromiseFn);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If then is not a function, fulfill promise with x.</span></span><br><span class="line">        resolve(x);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="comment">// If retrieving the property x.then results in a thrown exception e, reject promise with e as the reason.</span></span><br><span class="line">      <span class="comment">// If calling then throws an exception e, If resolvePromise or rejectPromise have been called, ignore it. Otherwise, reject promise with e as the reason.</span></span><br><span class="line">      <span class="keyword">if</span> (!isCalled) &#123;</span><br><span class="line">        reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">      isCalled = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// If x is not an object or function, fulfill promise with x.</span></span><br><span class="line">    resolve(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFullfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> promise2;</span><br><span class="line">  <span class="keyword">let</span> _this = <span class="keyword">this</span>;</span><br><span class="line">  <span class="comment">// If onFulfilled is not a function and promise1 is fulfilled, promise2 must be fulfilled with the same value as promise1.</span></span><br><span class="line">  onFullfilled = <span class="keyword">typeof</span> onFullfilled === <span class="string">'function'</span> ? onFullfilled : <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line">  <span class="comment">// If onRejected is not a function, promise2 must be rejected with the same reason as promise1.</span></span><br><span class="line">  onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> reason;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.status === STATUS.fulfilled) &#123;</span><br><span class="line">    <span class="comment">// onFullfilled(this.value);</span></span><br><span class="line">    <span class="comment">// onFulfilled and onRejected must be called as functions (i.e. with no this value).</span></span><br><span class="line">    promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// onFulfilled or onRejected must not be called until the execution context stack contains only platform code.</span></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Here “platform code” means engine, environment,</span></span><br><span class="line"><span class="comment">       * and promise implementation code. In practice,</span></span><br><span class="line"><span class="comment">       * this requirement ensures that onFulfilled and onRejected execute asynchronously,</span></span><br><span class="line"><span class="comment">       * after the event loop turn in which then is called, and with a fresh stack.</span></span><br><span class="line"><span class="comment">       * This can be implemented with either a “macro-task” mechanism such as setTimeout or setImmediate,</span></span><br><span class="line"><span class="comment">       * or with a “micro-task” mechanism such as MutationObserver or process.nextTick.</span></span><br><span class="line"><span class="comment">       * Since the promise implementation is considered platform code,</span></span><br><span class="line"><span class="comment">       * it may itself contain a task-scheduling queue or “trampoline” in which the handlers are called.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// If either onFulfilled or onRejected throws an exception e, promise2 must be rejected with e as the reason.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// If either onFulfilled or onRejected returns a value x,</span></span><br><span class="line">          <span class="keyword">const</span> x = onFullfilled(_this.value);</span><br><span class="line">          <span class="comment">// run the Promise Resolution Procedure [[Resolve]](promise2, x).</span></span><br><span class="line">          resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="number">0</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.status === STATUS.rejected) &#123;</span><br><span class="line">    <span class="comment">// onRejected(this.reason);</span></span><br><span class="line">    <span class="comment">// onFulfilled and onRejected must be called as functions (i.e. with no this value).</span></span><br><span class="line">    promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// onFulfilled or onRejected must not be called until the execution context stack contains only platform code.</span></span><br><span class="line">      setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// If either onFulfilled or onRejected throws an exception e, promise2 must be rejected with e as the reason.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// promise1 is rejected, promise2 must be rejected with the same reason as promise1.</span></span><br><span class="line">          <span class="comment">// If either onFulfilled or onRejected returns a value x,</span></span><br><span class="line">          <span class="keyword">const</span> x = onRejected(_this.reason);</span><br><span class="line">          <span class="comment">// run the Promise Resolution Procedure [[Resolve]](promise2, x).</span></span><br><span class="line">          resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          reject(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="number">0</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.status === STATUS.pending) &#123;</span><br><span class="line">    <span class="comment">// onFulfilled or onRejected must not be called until the execution context stack contains only platform code.</span></span><br><span class="line">    <span class="comment">// 因此仍在pending时需要封装一个回调</span></span><br><span class="line">    <span class="comment">// this.onFinishCb.push(&#123;</span></span><br><span class="line">    <span class="comment">//   onFullfilled,</span></span><br><span class="line">    <span class="comment">//   onRejected,</span></span><br><span class="line">    <span class="comment">// &#125;);</span></span><br><span class="line">    <span class="comment">// onFulfilled and onRejected must be called as functions (i.e. with no this value).</span></span><br><span class="line">    promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      _this.onFinishCb.push(&#123;</span><br><span class="line">        onFullfilled: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">          <span class="comment">// onFulfilled or onRejected must not be called until the execution context stack contains only platform code.</span></span><br><span class="line">          setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// If either onFulfilled or onRejected throws an exception e, promise2 must be rejected with e as the reason.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">const</span> x = onFullfilled(value);</span><br><span class="line">              <span class="comment">// run the Promise Resolution Procedure [[Resolve]](promise2, x).</span></span><br><span class="line">              resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">              reject(e);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">        onRejected: <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">          <span class="comment">// onFulfilled or onRejected must not be called until the execution context stack contains only platform code.</span></span><br><span class="line">          setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// If either onFulfilled or onRejected throws an exception e, promise2 must be rejected with e as the reason.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">const</span> x = onRejected(reason);</span><br><span class="line">              <span class="comment">// run the Promise Resolution Procedure [[Resolve]](promise2, x).</span></span><br><span class="line">              resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">              reject(e);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// then must return a promise. promise2 = promise1.then(onFulfilled, onRejected);</span></span><br><span class="line">  <span class="keyword">return</span> promise2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.prototype.catch = <span class="function"><span class="keyword">function</span> (<span class="params">onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">null</span>, onRejected);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (v <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    resolve(v);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.reject = <span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">_, reject</span>) </span>&#123;</span><br><span class="line">    reject(v);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span> (<span class="params">iterable</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(iterable)) &#123;</span><br><span class="line">      <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Promise.all accepts an array'</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> arrs = [...iterable];</span><br><span class="line">    <span class="keyword">var</span> results = <span class="keyword">new</span> <span class="built_in">Array</span>(arrs.length);</span><br><span class="line">    <span class="keyword">var</span> handlingCount = arrs.length;</span><br><span class="line">    <span class="keyword">if</span> (!handlingCount) &#123;</span><br><span class="line">      resolve(results);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">i, val</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (val &amp;&amp; val.then &amp;&amp; <span class="keyword">typeof</span> val.then === <span class="string">'function'</span>) &#123;</span><br><span class="line">          <span class="keyword">let</span> then = val.then;</span><br><span class="line">          then.call(</span><br><span class="line">            arrs[i],</span><br><span class="line">            <span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">              <span class="comment">// 如果回来的v仍然是个promise</span></span><br><span class="line">              resolvePromise(i, v)</span><br><span class="line">            &#125;,</span><br><span class="line">            reject,</span><br><span class="line">          )</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          results[i] = val;</span><br><span class="line">          <span class="keyword">if</span> (--handlingCount === <span class="number">0</span>) &#123;</span><br><span class="line">            resolve(results);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      arrs.forEach(<span class="function">(<span class="params">arr, i</span>) =&gt;</span> &#123;</span><br><span class="line">        resolvePromise(i, arr);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race = <span class="function"><span class="keyword">function</span> (<span class="params">iterable</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(iterable)) &#123;</span><br><span class="line">      <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Promise.all accepts an array'</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    iterable.forEach(<span class="function"><span class="params">eachMember</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">Promise</span>.resolve(eachMember).then(resolve, reject);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="https://yuzhounanhai.github.io/2019/09/29/实现符合promisea+规范/" data-title="实现符合Promise A+规范的promise" data-id="ckem6w7pp001pk8vx7e82lmae" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JS/">JS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原理/">原理</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/09/29/浅析Redux实现原理/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          浅析Redux实现原理
        
      </div>
    </a>
  
  
    <a href="/2019/09/29/原生AJAX编写入门/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">原生AJAX编写入门</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  <div class="github-card" data-github="yuzhounanhai" data-width="100%" data-height="" data-theme="default"></div>
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/其他/">其他</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端/">前端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/网络通信/">网络通信</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JS/">JS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LeetCode解题/">LeetCode解题</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redux/">Redux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TS/">TS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Vue/">Vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Webpack/">Webpack</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/http/">http</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/原理/">原理</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/笔记/">笔记</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/JS/" style="font-size: 20px;">JS</a> <a href="/tags/LeetCode解题/" style="font-size: 12.5px;">LeetCode解题</a> <a href="/tags/React/" style="font-size: 15px;">React</a> <a href="/tags/Redux/" style="font-size: 12.5px;">Redux</a> <a href="/tags/TS/" style="font-size: 10px;">TS</a> <a href="/tags/Vue/" style="font-size: 10px;">Vue</a> <a href="/tags/Webpack/" style="font-size: 10px;">Webpack</a> <a href="/tags/http/" style="font-size: 15px;">http</a> <a href="/tags/原理/" style="font-size: 17.5px;">原理</a> <a href="/tags/笔记/" style="font-size: 10px;">笔记</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">九月 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/09/29/简单实现虚拟Dom与Diff算法/">简单实现虚拟DOM与Diff算法</a>
          </li>
        
          <li>
            <a href="/2019/09/29/浅析VUE双向绑定原理/">浅析VUE双向绑定原理</a>
          </li>
        
          <li>
            <a href="/2019/09/29/深入了解AJAX/">深入了解AJAX</a>
          </li>
        
          <li>
            <a href="/2019/09/29/浅析Redux实现原理/">浅析Redux实现原理</a>
          </li>
        
          <li>
            <a href="/2019/09/29/实现符合promisea+规范/">实现符合Promise A+规范的promise</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 宇宙南海<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
</nav>
    

<script src="//cdn.jsdelivr.net/github-cards/latest/widget.js"></script>

<script src="/js/jquery-3.4.1.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>